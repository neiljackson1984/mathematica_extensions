(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)






rotate[object_,rotationangle_,anchorpoint_:{0,0}] :=
Replace[object,#,Infinity]& @
{

(*this is how we rotate Circle[...] constructs*)
(
circle_?(Head[#] == Circle &) :> Circle @@
{
rotatepoint[circle[[1]],rotationangle],
circle[[2]]
}
~Join~ 
If[Length[circle] == 3, {rotationangle*{1,1} + circle[[3]]},{}]
),

(*this is how we rotate Point[...] constructs*)
(
point_?(Head[#] == Point &) :> 
Replace[point,#,Infinity]& @
{
xy_?(MatchQ[#,{_?(NumericQ[#]&), _?(NumericQ[#]&)}]&) :> rotatepoint[xy,rotationangle]
}

),

(*this is how we rotate Line[...] constructs*)
(
line_?(Head[#] == Line &) :> 
Replace[line,#,Infinity]& @
{
xy_?(MatchQ[#,{_?(NumericQ[#]&), _?(NumericQ[#]&)}]&) :> rotatepoint[xy,rotationangle]
}
)
};



translate[object_, translationvector_] :=
Flatten[#,1]& @@ Replace[{object},#,Infinity]& @ (*the extra enclosing {} and flattening is required because, for some reason, when Replace is called with a levelspec (third argument), it does not do any replacement at the zeroeth level.  Without this, translate[Point[1,1],{1,1}], for instance would not work.  You would have to enclose the point in braces.  But, with this fix, translate can accept bare Point[], Circle[],... constructs and deal with them sensibly.*)
{

(*this is how we translate Circle[...] constructs*)
(
circle_?(Head[#] == Circle &) :> Circle @@
{circle[[1]] + translationvector} ~Join~ Rest[Level[circle,1]]
),

(*this is how we translate Point[...] constructs*)
(
point_?(Head[#] == Point &) :> 
Replace[point,#,Infinity]& @
{
xy_?(MatchQ[#,{_?(NumericQ[#]&), _?(NumericQ[#]&)}]&) :> xy + translationvector
}

),

(*this is how we translate Line[...] constructs*)
(
line_?(Head[#] == Line &) :> 
Replace[line,#,Infinity]& @
{
xy_?(MatchQ[#,{_?(NumericQ[#]&), _?(NumericQ[#]&)}]&) :> xy + translationvector
}
)
};



(*FOR THE BELOW TWO FUNCTIONS, SEE IF IT IS POSSIBLE TO DEFINE THEM IN AN OVERLOADED FASHION (ONE VERSION FOR VECTOR, ONE FOR ANGLE), RATHER THAN EVALUATING THE TYPE OF THE ARGUMENT EXPLICITLY WITHIN THE FUNCTION*)


reflect[object_, vectororangle_,anchorpoint_:{0,0}] :=
Replace[object,#,Infinity]& @
{

(*this is how we reflect Circle[...] constructs*)
(
circle_?(Head[#] == Circle &) :> Circle @@
{
reflectpoint[circle[[1]],vectororangle,anchorpoint],
circle[[2]]
}
~Join~ 
If[Length[circle] == 3, {reflectanglerange[ circle[[3]] , vectororangle]},{}]
),

(*this is how we reflect Point[...] constructs*)
(
point_?(Head[#] == Point &) :> 
Replace[point,#,Infinity]& @
{
xy_?(MatchQ[#,{_?(NumericQ[#]&), _?(NumericQ[#]&)}]&) :> reflectpoint[xy , vectororangle, anchorpoint]
}

),

(*this is how we reflect Line[...] constructs*)
(
line_?(Head[#] == Line &) :> 
Replace[line,#,Infinity]& @
{
xy_?(MatchQ[#,{_?(NumericQ[#]&), _?(NumericQ[#]&)}]&) :> reflectpoint[xy , vectororangle, anchorpoint]
}
)
};



(*this will reflect the point about the line defined by the anchorpoint and normalizable vector (or the anchorpoint and the angle if the third asrgument is a number instead of a list. *)
reflectpoint[point_,vectororangle_,anchorpoint_:{0,0}] := 
Block[
{r},
If[
MatchQ[vectororangle,{_?(NumericQ[#]&), _?(NumericQ[#]&)}],
r = Normalize[vectororangle]
];
If[
NumericQ[vectororangle], 
r = {Cos[vectororangle],Sin[vectororangle]}
];
Return[anchorpoint + 2*( (point-anchorpoint).r)  *r -(point-anchorpoint)];
];


(*this will reflect the anglerange {angle1, angle2} about the line defined by the anchorpoint and angle.  this will be used when reflecting arcs.*)
reflectanglerange[anglerange_,vectororangle_] :=  
Block[
{\[Theta]},
If[
(MatchQ[#,{_?(NumericQ[#]&), _?(NumericQ[#]&)}]&) @ vectororangle,
\[Theta] = angle[vectororangle]
];
If[
NumericQ @ vectororangle, 
\[Theta] = vectororangle
];
Return[Reverse[2*\[Theta]-anglerange]];
];









