(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(*The bubbledline function is given as an input a list of points representing a polygon or straight-line contour that we wish to mill out with an endmill of a given diameter and we wish to remove everything inside the polygon, even if we have to remove some material outside of the polygon in order to accomplish this.  The bubbledline function returns a list of graphics primitives which can be fed into millwrite and set for spiral pocket to accomplish the required milling*)


graphicsduplicate[graphicsobject_,offsetpositions_] := Table[translate[graphicsobject,position],{position,offsetpositions}];


(*this function returns a list of graphics primitives containing one element a Line[] outlining the rectangle with the given lower left and upper right corner*)
linerectangle[lowerleft_,upperright_,roundingradius_:0] := 
Block[
{dimensions},
If[
roundingradius > 0,
dimensions=upperright- lowerleft;
Return[
{
Circle[lowerleft+{roundingradius,roundingradius},roundingradius,{Pi,3/2*Pi}],
Line[{lowerleft+{roundingradius,0},lowerleft+{dimensions[[1]]-roundingradius,0}}],
Circle[lowerleft+{dimensions[[1]]-roundingradius,roundingradius},roundingradius,{3/2*Pi,2*Pi}],
Line[{lowerleft+{dimensions[[1]],roundingradius},lowerleft+{dimensions[[1]],dimensions[[2]]-roundingradius}}],
Circle[lowerleft+{dimensions[[1]]-roundingradius,dimensions[[2]]-roundingradius},roundingradius,{0,Pi/2}],
Line[{lowerleft+{dimensions[[1]]-roundingradius,dimensions[[2]]},lowerleft+{roundingradius,dimensions[[2]]}}],
Circle[lowerleft+{roundingradius,dimensions[[2]]-roundingradius},roundingradius,{Pi/2,Pi}],
Line[{lowerleft+{0,dimensions[[2]]-roundingradius},lowerleft+{0,roundingradius}}]
}
];
];

Return[
Line[
{
lowerleft,
{upperright[[1]],lowerleft[[2]]},
upperright,
{lowerleft[[1]],upperright[[2]]},
lowerleft
}
]
];

];

(*linerectangle[corner_,dx_,dy_ ] := linerectangle[corner,corner+{dx,dy}];*)


(*The following are valid ways of specifying the rectangle:
center and extent;
corner1 and extent;
corner2 and extent (in which case extent should be subtracted from corner2);
corner1 and corner2;
*)

linerect[OptionsPattern[ {center -> "notset",corner1->"notset", corner2 -> "notset", extent -> "notset", roundingradius -> 0}]] := 
Block[
{},


If[
!StringQ[OptionValue[extent]],
If[
!StringQ[OptionValue[center]],(*case: rectangle specified with center and extent*)
Return[
linerectangle[OptionValue[center]-OptionValue[extent]/2,OptionValue[center]+OptionValue[extent]/2,OptionValue[roundingradius]]
]
];
If[
!StringQ[OptionValue[corner1]],(*case: rectangle specified with corner1 and extent*)
Return[
linerectangle[OptionValue[corner1],OptionValue[corner1]+OptionValue[extent],OptionValue[roundingradius]]
]
];
If[
!StringQ[OptionValue[corner2]],(*case: rectangle specified with corner2 and extent*)
Return[
linerectangle[OptionValue[corner2],OptionValue[corner2]-OptionValue[extent],OptionValue[roundingradius]]
]
];
If[
StringQ[OptionValue[corner1]],(*case: rectangle specified extent only, corner1 taken implicitly to be {0,0}*)
Return[
linerectangle[{0,0},{0,0}+OptionValue[extent],OptionValue[roundingradius]]
]
];
];

(*case: rectangle specified with corner1 and corner2*)
If[
!StringQ[OptionValue[corner1]] &&  !StringQ[OptionValue[corner2]],
Return[
linerectangle[OptionValue[corner1],OptionValue[corner2],OptionValue[roundingradius]]
]
];

];



(*lineroundedrectangle[{lowerleftcorner_,upperrightcorner_},roundingradius_]:=
Block[
{dimensions},
dimensions=upperrightcorner - lowerleftcorner;

{
Circle[lowerleftcorner+{roundingradius,roundingradius},roundingradius,{Pi,3/2*Pi}],
Line[{lowerleftcorner+{roundingradius,0},lowerleftcorner+{dimensions[[1]]-roundingradius,0}}],
Circle[lowerleftcorner+{dimensions[[1]]-roundingradius,roundingradius},roundingradius,{3/2*Pi,2*Pi}],
Line[{lowerleftcorner+{dimensions[[1]],roundingradius},lowerleftcorner+{dimensions[[1]],dimensions[[2]]-roundingradius}}],
Circle[lowerleftcorner+{dimensions[[1]]-roundingradius,dimensions[[2]]-roundingradius},roundingradius,{0,Pi/2}],
Line[{lowerleftcorner+{dimensions[[1]]-roundingradius,dimensions[[2]]},lowerleftcorner+{roundingradius,dimensions[[2]]}}],
Circle[lowerleftcorner+{roundingradius,dimensions[[2]]-roundingradius},roundingradius,{Pi/2,Pi}],
Line[{lowerleftcorner+{0,dimensions[[2]]-roundingradius},lowerleftcorner+{0,roundingradius}}]
}

];*)


(*shortside should be set to "upper", "lower", "left", or "right"*)
trapezoid[OptionsPattern[ {center -> "notset",alteredsidelength-> "notset", alteredside -> "top",corner1 -> "notset", boundingrectangle -> "notset", roundingradius -> 0}]]:=
Block[
{vertices, lowerleft,pointmovement},
If[
!StringQ[OptionValue[corner1]],
lowerleft = OptionValue[corner1]
];
If[
!StringQ[OptionValue[center]],
lowerleft = OptionValue[center] - 1/2*OptionValue[boundingrectangle]
];
vertices =  
{
lowerleft , 
lowerleft +{ OptionValue[boundingrectangle][[1]],0}, 
lowerleft + OptionValue[boundingrectangle],
lowerleft + {0,OptionValue[boundingrectangle][[2]]}
};



Switch[
OptionValue[alteredside],
"top",         pointmovement = 1/2 (OptionValue[boundingrectangle][[1]] - OptionValue[alteredsidelength]);vertices[[3,1]] -=  pointmovement; vertices[[4,1 ]] +=  pointmovement;,
"lower",     pointmovement = 1/2 (OptionValue[boundingrectangle][[1]] - OptionValue[alteredsidelength]); vertices[[2,1]] -=  pointmovement; vertices[[1,1 ]] +=  pointmovement;,
"left"  ,     pointmovement = 1/2 (OptionValue[boundingrectangle][[2]] - OptionValue[alteredsidelength]); vertices[[4,2]] -=  pointmovement; vertices[[1,2 ]] +=  pointmovement;,
"bottom",  pointmovement = 1/2 (OptionValue[boundingrectangle][[2]] - OptionValue[alteredsidelength]); vertices[[3,2]] -=  pointmovement; vertices[[2,2 ]] +=  pointmovement;
];

Return[
Line[
Append[vertices,First[vertices]]
]
]
];

circle[OptionsPattern[{center-> {0,0},radius-> "notset",diameter->"notset",crosshairs-> False}]] :=
Block[
{r,output},
If[
!StringQ[OptionValue[radius]],
r = OptionValue[radius]
];

If[
!StringQ[OptionValue[diameter]],
r= OptionValue[diameter] /2
];

output = {Circle[OptionValue[center],r]};
If[
OptionValue[crosshairs],
output = output ~Join~ 
{
Line[
{
OptionValue[center]-{0,r},
OptionValue[center]+{0,r}
}
],
Line[
{
OptionValue[center]-{r,0},
OptionValue[center]+{r,0}
}
]
};
];

Return[output];
];

(*this is the rotation matrix which rotates a vector counterclockwise by an angle \[Theta]*)
rotatepoint[point_,rotationangle_] := 
{
{Cos[rotationangle],-Sin[rotationangle]},
{Sin[rotationangle],Cos[rotationangle]}
}.point;

(* for nonzero points, returns the angle in the range [-Pi, Pi) which would appear in the polar representation of the point.*)
angle[point_] :=
If[point[[2]]>= 0, 1, -1] * ArcCos[Normalize[point][[1]]] ;


(*this function takes a list of points just as the Line[] function does.  It produces a list of graphics primitives composing the *)
bubbledline[listofpoints_,cuttingdiameter_] :=
Block[
{i,output={},a,b,c,d=cuttingdiameter,\[Theta],e,f,g,n,p,h,m, circledrawingangles,hlist,mlist,maxi,bubbles = {},sides},
If[
Length[listofpoints] <= 2,
Return[{Line[listofpoints]}] 
];

hlist = Table["h" <> ToString[i],{i,1,Length[listofpoints]}];
mlist = Table["m" <> ToString[i],{i,1,Length[listofpoints]}];

maxi = If[First[listofpoints] == Last[listofpoints], Length[listofpoints],Length[listofpoints]-1];

For[i=2,i<= maxi,i++,
a = listofpoints[[i-1]];
b= listofpoints[[i]];
c = listofpoints[[If[i != Length[listofpoints],i+1,2]]];


\[Theta] := ArcCos[Normalize[a-b].Normalize[c-b]];

e := b+ d/2*Normalize [Normalize[a-b] + Normalize[c-b]] ;

f := b+ d*Cos[\[Theta]/2] *Normalize[a-b];
g := b+ d*Cos[\[Theta]/2] *Normalize[c-b];

n :=e +d/2* Normalize[a-b-4/d^2 *((e-b)*((e-b).(a-b)))];
p :=e +d/2* Normalize[c-b-4/d^2 *((e-b)*((e-b).(c-b)))];


h := (b-e)*(1-1/Tan[\[Theta]/2]) +n;
m := (b-e)*(1-1/Tan[\[Theta]/2]) +p;


If[
\[Theta] >= Pi/2,
h = f;
n=f;
m=g;
p=g;
 ];


circledrawingangles :=
{0,Re[ArcCos[Normalize[(p-e)].Normalize[(n-e)]]]}   +  If[rotatepoint[p-e,Pi/2].(b-e) >0,angle[p-e],angle[n-e]] ;
hlist[[i]] = h;
mlist[[i]] = m;

bubbles = 
Join[
bubbles,
{
Line[{h,n}],
Circle[e,d/2,circledrawingangles],
Line[{p,m}]
}
]
];

(*at this point, all the bubbles are created*)

sides = Table[ Line[{mlist[[i]],hlist[[i+1]]}],{i,2,Length[listofpoints]-2}];

If[
First[listofpoints] == Last[listofpoints],
sides=
Join[
sides,
{
Line[{mlist[[Length[listofpoints]]],hlist[[2]]}],
Line[{mlist[[Length[listofpoints]-1]],hlist[[Length[listofpoints]]]}]
}
]
,
sides=
Join[
sides,
{
Line[{First[listofpoints],hlist[[2]]}],
Line[{mlist[[Length[listofpoints]-1]],Last[listofpoints]}]
}
]
];

Return[Join[sides,bubbles]];

];

(*returns a list of vertex points of a regular polygon with a certain number of sides, radius, offset angle and center point.  The first vertex point is repeated at the end of the list*)
regularvertices[centerpoint_,radius_,numsides_,offsetangle_] := 
Block[
{i,output},
output = Array["shit",numsides];
output[[1]] = rotate[{radius,0},offsetangle];
For[
i=2,
i<= numsides,
 i++,
output[[i]] = rotate[output[[1]],(i-1)*2*Pi/numsides];
];
AppendTo[output,output[[1]]]; (*this causes adds the first point onto the end of the list so that this list can be used to define a closed polygon*)
output =  Map[#+centerpoint &,output];
Return[output];
];






